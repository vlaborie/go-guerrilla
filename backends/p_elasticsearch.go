// +build full elasticsearch

package backends

import (
    "fmt"
    "bytes"
    "context"
    "encoding/json"

    "github.com/flashmob/go-guerrilla/mail"

    "github.com/elastic/go-elasticsearch/v7"
    "github.com/elastic/go-elasticsearch/v7/esapi"
)

// ----------------------------------------------------------------------------------
// Processor Name: elasticsearch
// ----------------------------------------------------------------------------------
// Description   : Saves e (email data and header) to elasticsearch using the hash
//               : generated by the "hash" processor and stored in e.Hashes
//               : Split e into multiples elements (one by recipient) before upload
// ----------------------------------------------------------------------------------
// Config Options: none for now, use only default settings from elastic/go-elasticsearch
//               :
// --------------:-------------------------------------------------------------------
// Input         : e
// ----------------------------------------------------------------------------------
// Output        :
// ----------------------------------------------------------------------------------
func init() {
    processors["elasticsearch"] = func() Decorator {
        return Elasticsearch()
    }
}

type ElasticsearchEnvelope struct {
    *mail.Envelope
    // Recipient
    Recipient mail.Address `json:"recipient"`
    // Body stores message body
    Body string `json:"body"`
}

type ElasticsearchProcessor struct {
    isConnected bool
    conn *elasticsearch.Client
}

func (e *ElasticsearchProcessor) elasticsearchConnection() (err error) {
    if e.isConnected == false {
        e.conn, err = elasticsearch.NewDefaultClient()
        if err != nil {
           return err
        }
        e.isConnected = true
    }
    return nil
}

func Elasticsearch() Decorator {
    elasticsearchClient := &ElasticsearchProcessor{}

    // Connect to Elasticsearch
    Svc.AddInitializer(InitializeWith(func(backendConfig BackendConfig) error {
        if elasticsearchErr := elasticsearchClient.elasticsearchConnection(); elasticsearchErr != nil {
            err := fmt.Errorf("elasticsearch cannot connect, check your settings: %s", elasticsearchErr)
            return err
        }
        return nil
    }))

    // When shutting down
///    Svc.AddShutdowner(ShutdownWith(func() error {
///        if elasticsearchClient.isConnected {
///            return nil
///        }
///        return nil
///    }))

    return func(p Processor) Processor {
        return ProcessWith(func(e *mail.Envelope, task SelectTask) (Result, error) {
            if task == TaskSaveMail {
                for i, _ := range e.RcptTo {
                    // Create ElasticsearchEnvelope from mail.Envelope
                    ElasticsearchEnvelope := ElasticsearchEnvelope{
                        Envelope: e,
                        Recipient: e.RcptTo[i],
                        Body: e.Data.String(),
                    }

                    // prepare Elasticsearch request
                    req := esapi.IndexRequest{
                        Index: "test",
                        DocumentID: e.Hashes[i],
                        Refresh: "true",
                    }
                    j, _ := json.Marshal(ElasticsearchEnvelope)
                    req.Body = bytes.NewReader(j)

                    // perform the request
                    res, err := req.Do(context.Background(), elasticsearchClient.conn)
                    if err != nil {
                        Log().WithError(err).Warn("Error while uploading to elasticsearch")
                    }
                    defer res.Body.Close()
                }
                return p.Process(e, task)
            } else {
                return p.Process(e, task)
            }
        })
    }
}
